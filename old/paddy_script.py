# -*- coding: utf-8 -*-
"""smt-noddi-simulations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ymnrHmUwg2G_5iQcp7sgdmLM1VzTIy1a
"""

#load modules
import os
import numpy as np
import scipy.stats
import matplotlib.pyplot as plt
import nibabel as nib

#clone dmipy
# !git clone https://github.com/AthenaEPI/dmipy.git

#change to the relevant directory
# os.chdir('dmipy')
import dmipy

#install dmipy
# !pip install -e .

# load the necessary dmipy modules
from dmipy.core import modeling_framework
from dmipy.signal_models import cylinder_models, gaussian_models
from dmipy.distributions.distribute_models import BundleModel
from dmipy.core import modeling_framework
from dmipy.data import saved_acquisition_schemes
from dmipy.core.acquisition_scheme import acquisition_scheme_from_bvalues

#set up the smt-noddi model
stick = cylinder_models.C1Stick()
zeppelin = gaussian_models.G2Zeppelin()
ball = gaussian_models.G1Ball()

bundle = BundleModel([stick, zeppelin])
bundle.set_tortuous_parameter('G2Zeppelin_1_lambda_perp',
    'C1Stick_1_lambda_par','partial_volume_0')
bundle.set_equal_parameter('G2Zeppelin_1_lambda_par', 'C1Stick_1_lambda_par')
bundle.set_fixed_parameter('G2Zeppelin_1_lambda_par', 1.7e-9)

smt_noddi_mod = modeling_framework.MultiCompartmentSphericalMeanModel(models=[bundle, ball])

#fix the isotropic diffusivity
smt_noddi_mod.set_fixed_parameter('G1Ball_1_lambda_iso', 3e-9)

#get the saved hcp scheme
acq_scheme_full = saved_acquisition_schemes.wu_minn_hcp_acquisition_scheme()

np.ones((3,))

smt_noddi_mod.parameter_names

#choose some parameters for the simulated SMT-NODDI model 
#SD1WatsonDistributed_1_SD1Watson_1_odi = [0.2, 0.6, 0.7]
#SD1WatsonDistributed_1_partial_volume_0 = [0.8, 0.6, 0.9]

#limits on the parameters for wm/gm/csf
stick_par_wm = [1e-9, 2e-9]
stick_par_gm = [1e-9, 2e-9]
stick_par_csf = [1e-9, 2e-9]
zep_par_wm = [1.5e-9, 2.5e-9]
zep_par_gm = [1.5e-9, 2.5e-9]
zep_par_csf = [1.5e-9, 2.5e-9]
odi_wm = [0.01, 0.3]
odi_gm = [0.6, 0.9]
odi_csf = [0, 1]
f_stick_wm = [0.7, 0.9]
f_stick_gm = [0.6, 8]
f_stick_csf = [0.8, 1]
f_bundle_wm = [0.7, 0.9]
f_bundle_gm = [0.8, 1]
f_bundle_csf = [0, 0.2]
# f_free_wm = 1-f_bundle_wm
# f_free_gm = 1-f_bundle_gm
# f_free_csf = 1-f_bundle_csf


#number of voxels for each tissue type
#n_wm = 40000
#n_gm = 20000
#n_csf = 10000 
n_wm = 500
n_gm = 300
n_csf = 100

ROImask = np.concatenate((np.zeros((n_wm,)),np.ones((n_gm,)),2*np.ones((n_csf,))))                      

stick_par = np.concatenate((np.random.uniform(low=stick_par_wm[0],high=stick_par_wm[1], size = n_wm),
                      np.random.uniform(low=stick_par_gm[0],high=stick_par_gm[1], size = n_gm),
                      np.random.uniform(low=stick_par_csf[0],high=stick_par_csf[1], size = n_csf)))

zep_par = np.concatenate((np.random.uniform(low=zep_par_wm[0],high=zep_par_wm[1], size = n_wm),
                      np.random.uniform(low=zep_par_gm[0],high=zep_par_gm[1], size = n_gm),
                      np.random.uniform(low=zep_par_csf[0],high=zep_par_csf[1], size = n_csf)))

odi = np.concatenate((np.random.uniform(low=odi_wm[0],high=odi_wm[1], size = n_wm),
                      np.random.uniform(low=odi_gm[0],high=odi_gm[1], size = n_gm),
                      np.random.uniform(low=odi_csf[0],high=odi_csf[1], size = n_csf)))                

f_stick = np.concatenate((np.random.uniform(low=f_bundle_wm[0],high=f_bundle_wm[1], size = n_wm),
                      np.random.uniform(low=f_bundle_gm[0],high=f_bundle_gm[1], size = n_gm),
                      np.random.uniform(low=f_bundle_csf[0],high=f_bundle_csf[1], size = n_csf)))

f_bundle = np.concatenate((np.random.uniform(low=f_bundle_wm[0],high=f_bundle_wm[1], size = n_wm),
                      np.random.uniform(low=f_bundle_gm[0],high=f_bundle_gm[1], size = n_gm),
                      np.random.uniform(low=f_bundle_csf[0],high=f_bundle_csf[1], size = n_csf)))

f_free = 1 - f_bundle


#images are a bit easier to deal with?
#n_wm+n_gm_n_csf
#np.reshape((np.sqrt(n_wm+n_gm_n_csf),np.sqrt()))

#put into a big parameter vector that can be passed into simulate_signal
# parameters_smt_noddi = smt_noddi_mod.parameters_to_parameter_vector(BundleModel_1_C1Stick_1_lambda_par=stick_par,
#                                                                 BundleModel_1_G2Zeppelin_1_lambda_par=zep_par,
#                                                                 BundleModel_1_partial_volume_0=f_stick,
#                                                                 partial_volume_0=f_bundle,
#                                                                 partial_volume_1=f_free)
parameters_smt_noddi = smt_noddi_mod.parameters_to_parameter_vector(BundleModel_1_partial_volume_0=f_stick,
                                                                partial_volume_0=f_bundle,
                                                                partial_volume_1=f_free)
signals = smt_noddi_mod.simulate_signal(acq_scheme_full,smt_noddi_mod)

grad_dirs = np.tile([1,1,1] / np.linalg.norm([1,1,1]), [np.unique(acq_scheme_full.bvalues).shape[0], 1])
acq_scheme = acquisition_scheme_from_bvalues(np.unique(acq_scheme_full.bvalues), grad_dirs, acq_scheme_full.delta[0], acq_scheme_full.Delta[0])
lsq_fit = smt_noddi_mod.fit(acq_scheme, signals)
parameter_vector_lsq = lsq_fit.fitted_parameters_vector

'''
#add some noise
def add_noise(data, scale=0.02):
    data_real = data + np.random.normal(scale=scale, size=np.shape(data))
    data_imag = np.random.normal(scale=scale, size=np.shape(data))
    data_noisy = np.sqrt(data_real**2 + data_imag**2)

    return data_noisy

SNR = [10,25,50,75,100]
noisy_signals = {}
for i in range(0,len(SNR)):
  noisy_signals[SNR[i]] = add_noise(signals,scale=1/SNR[i])

os.mkdir('sims')
#save
#as numpy
np.save('sims/noisy_signals_smt_noddi.npy',noisy_signals)
np.save('sims/signals_smt_noddi.npy',signals)
np.save('sims/ground_truth_smt_noddi_parameters.npy',parameters_smt_noddi)
np.save('sims/ground_truth_ROImask.npy',ROImask)
#as nifti
for SNR in noisy_signals:
  nib.save(nib.Nifti1Image(noisy_signals[SNR], np.eye(4)),'sims/SNR_' + str(SNR) + '_noisy_signals_smt_noddi.nii.gz')
nib.save(nib.Nifti1Image(signals, np.eye(4)),'sims/signals_smt_noddi.nii.gz')
nib.save(nib.Nifti1Image(ROImask, np.eye(4)),'sims/ground_truth_ROImask.nii.gz')

import shutil
shutil.make_archive('sims', 'zip', 'sims')
'''